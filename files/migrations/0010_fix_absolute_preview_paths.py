# Generated by Django 5.2.7 on 2025-11-13 14:47

import logging
import os

from django.conf import settings
from django.db import migrations

logger = logging.getLogger(__name__)


def fix_absolute_preview_paths(apps, schema_editor):
    """
    Fix preview_file_path fields that contain absolute filesystem paths.

    Convert paths like:
      /home/cinemata/cinematacms/media_files/encoded/22/admin/file.gif
    to:
      encoded/22/admin/file.gif
    """
    Media = apps.get_model("files", "Media")
    Encoding = apps.get_model("files", "Encoding")

    # Get MEDIA_ROOT - use settings if available, otherwise use common paths
    media_root = getattr(settings, "MEDIA_ROOT", "")
    if not media_root:
        # Fallback pattern for fixing paths from production deployments
        common_roots = [
            "/home/cinemata/cinematacms/media_files/",  # Production deployment path
        ]
    else:
        # Convert pathlib.Path to string if needed
        media_root = os.fspath(media_root) if hasattr(media_root, "__fspath__") else str(media_root)
        # Ensure trailing slash for consistent prefix removal
        media_root = media_root if media_root.endswith("/") else media_root + "/"
        common_roots = [media_root]

    # Fix Media.preview_file_path
    fixed_count = 0
    error_count = 0
    # Exclude both NULL and empty strings, use iterator() for memory efficiency
    media_queryset = Media.objects.filter(preview_file_path__isnull=False).exclude(preview_file_path="")

    for media in media_queryset.iterator(chunk_size=1000):
        old_path = media.preview_file_path
        new_path = old_path

        # Remove any of the common root paths
        for root in common_roots:
            if old_path.startswith(root):
                new_path = old_path.replace(root, "", 1)
                break

        # Also handle paths that start with just /
        if new_path.startswith("/") and "/" in new_path[1:]:
            # Find where the actual media path starts (e.g., after encoded/, original/, etc.)
            for prefix in ["encoded/", "original/", "hls/", "videos/"]:
                if prefix in new_path:
                    idx = new_path.find(prefix)
                    new_path = new_path[idx:]
                    break

        if new_path != old_path:
            try:
                media.preview_file_path = new_path
                media.save(update_fields=["preview_file_path"])
                fixed_count += 1
            except Exception as e:
                logger.error(f"Failed to update Media {media.pk}: {e}")
                error_count += 1

    logger.info(f"Fixed {fixed_count} Media preview_file_path entries ({error_count} errors)")

    # Fix Encoding.chunk_file_path (similar logic)
    fixed_chunks = 0
    error_chunks = 0
    # Exclude both NULL and empty strings, use iterator() for memory efficiency
    encoding_queryset = Encoding.objects.filter(chunk_file_path__isnull=False).exclude(chunk_file_path="")

    for encoding in encoding_queryset.iterator(chunk_size=1000):
        old_path = encoding.chunk_file_path
        new_path = old_path

        for root in common_roots:
            if old_path.startswith(root):
                new_path = old_path.replace(root, "", 1)
                break

        if new_path.startswith("/") and "/" in new_path[1:]:
            for prefix in ["encoded/", "original/", "hls/", "videos/"]:
                if prefix in new_path:
                    idx = new_path.find(prefix)
                    new_path = new_path[idx:]
                    break

        if new_path != old_path:
            try:
                encoding.chunk_file_path = new_path
                encoding.save(update_fields=["chunk_file_path"])
                fixed_chunks += 1
            except Exception as e:
                logger.error(f"Failed to update Encoding {encoding.pk}: {e}")
                error_chunks += 1

    logger.info(f"Fixed {fixed_chunks} Encoding chunk_file_path entries ({error_chunks} errors)")


def reverse_func(apps, schema_editor):
    # No reverse operation - we don't want to restore absolute paths
    # Parameters required by Django migration signature but not used
    pass


class Migration(migrations.Migration):
    dependencies = [
        ("files", "0009_backfill_filename_fields"),
    ]

    operations = [
        migrations.RunPython(fix_absolute_preview_paths, reverse_func),
    ]
